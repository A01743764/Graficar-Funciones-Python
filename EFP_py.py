# -*- coding: utf-8 -*-
"""ProyectoIPC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r1zdXEXI0W6NpJiPSX-HXx5nOh3H3hQ8

# Evaluador de Funciones Básico
### Jesús Oscar Flores Cota - A01743764

En este evaluador de funciones es posible conocer los valores y gráficas, dados los respectivos datos, de las siguientes funciones:

Función Lineal: $$f(x) = mx + b$$

Función Cuadrática: $$f(x) = ax^2 + bx + c$$

Función Cúbica: $$f(x) = ax^3 + bx^2 + cx + d$$

Función Exponencial: $$f(x) = a^x$$

Función Logarítmica: $$f(x) = log_a(x)$$

Función Racional: $$f(x) = \frac{a}{bx}$$

Funciones de Raíz: $$f(x) = \sqrt[n]{x}$$
"""

#Importación de librerías y encontrar el tipo de función a evaluar
import numpy as np
import matplotlib.pyplot as plt
import math
#EL ARCHIVO DE REGISTRO SE GUARDA UNA VEZ SE CIERRA LA IMAGEN (en caso de usar thonny)
print("Bienvenido al evaluador de funciones, en el archivo registro.txt \nse encuentran las funciones que haz evaluado.")
tipo_funcion = int(input("¿Qué tipo de función desea evaluar? \nLineal = 1\nCuadratica = 2\nCubica = 3\nExponencial = 4\nLogarítmica = 5\nRacional = 6\nRaíz = 7\n\n"))
#Asegurarse de que se inserta el número correcto
if (tipo_funcion > 7) or (tipo_funcion < 1):
  print("Opción no válida")

"""###Bloque de funcion lineal"""

#Bloque de Función Lineal
def func_lin():
  f = open("registro.txt", "a")
  vls_x = []
  vls_y = []

  print("La función lineal cumple con la ecuación general:\nf(x) = mx + b\n")
  m = float(input("Ingrese el valor de m: "))
  b = float(input("Ingrese el valor de b: "))
  print("\nLa función lineal es:\nf(x) = ",m,"x + ",b)
  fx="f(x) = "+str(m)+"x + "+str(b)+"\n\n"
  f.write(fx)

  #Saber los valores iniciales y finales y cuanto paso va a haber para la evaluación

  val1 = float(input("\nIngrese el valor inferior para evaluar: "))
  val2 = float(input("Ingrese el valor superior: "))
  intervalo = float(input("Ingrese el intervalo: "))

  #Evalúa los valores de X y Y, en caso de que el valor uno sea mayor no vuelve a pedir los datos, solo los invierte
  if val1 > val2:
    while val2 <= val1:
      vls_x.append(val2)
      vls_y.append(m*val2 + b)
      val2 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  elif val1 < val2:
    while val1 <= val2:
      vls_x.append(val1)
      vls_y.append(m*val1 + b)
      val1 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  plt.plot(vls_x, vls_y)
  plt.savefig('lineal.png')
  plt.show()

"""###Bloque de funcion cuadratica"""

#Bloque de funcion cuadratica
def func_cua():
  file = open("registro.txt", "a")
  vls_x = []
  vls_y = []

  print("La función cuadratica cumple con la ecuación general:\nf(x) = ax^2 + bx + c\n")
  a = float(input("Ingrese el valor de a: "))
  b = float(input("Ingrese el valor de b: "))
  c = float(input("Ingrese el valor de c: "))
  print("\nLa función cuadrática es:\nf(x) = ",a,"x^2 + ",b,"x + ",c)
  fx="f(x) = "+str(a)+"x^2 + "+str(b)+"x + "+str(c)+"\n\n"
  f.write(fx)

  #Saber los valores iniciales y finales y cuanto paso va a haber para la evaluación

  val1 = float(input("\nIngrese el valor inferior para evaluar: "))
  val2 = float(input("Ingrese el valor superior: "))
  intervalo = float(input("Ingrese el intervalo: "))

  #Evalúa los valores de X y Y, en caso de que el valor uno sea mayor no vuelve a pedir los datos, solo los invierte
  if val1 > val2:
    while val2 <= val1:
      vls_x.append(val2)
      vls_y.append(a*math.pow(val2,2) + b*val2 + c)
      val2 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  elif val1 < val2:
    while val1 <= val2:
      vls_x.append(val1)
      vls_y.append(a*math.pow(val1,2) + b*val2 + c)
      val1 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  plt.plot(vls_x, vls_y)
  plt.savefig('cuadratica.png')
  plt.show()

"""###Bloque de funcion Cúbica"""

#Bloque de funcion cubica
def func_cubi():
  f = open("registro.txt", "a")
  vls_x = []
  vls_y = []

  print("La función cubica cumple con la ecuación general:\nf(x) = ax^3 + bx^2 + cx + d\n")
  a = float(input("Ingrese el valor de a: "))
  b = float(input("Ingrese el valor de b: "))
  c = float(input("Ingrese el valor de c: "))
  d = float(input("Ingrese el valor de d: "))
  print("\nLa función cuadrática es:\nf(x) = ",a,"x^3 + ",b,"x^2 + ",c,"x + ",d)
  fx="f(x) = "+str(a)+"x^3 + "+str(b)+"x^2 + "+str(c)+"x + "+str(d)+"\n\n"
  f.write(fx)

  #Saber los valores iniciales y finales y cuanto paso va a haber para la evaluación

  val1 = float(input("\nIngrese el valor inferior para evaluar: "))
  val2 = float(input("Ingrese el valor superior: "))
  intervalo = float(input("Ingrese el intervalo: "))

  #Evalúa los valores de X y Y, en caso de que el valor uno sea mayor no vuelve a pedir los datos, solo los invierte
  if val1 > val2:
    while val2 <= val1:
      vls_x.append(val2)
      vls_y.append(a*math.pow(val2,3) + b*math.pow(val2,2) + c*val2 + d)
      val2 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  elif val1 < val2:
    while val1 <= val2:
      vls_x.append(val1)
      vls_y.append(a*math.pow(val1,3) + b*math.pow(val1,2) + c*val1 + d)
      val1 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  plt.plot(vls_x, vls_y)
  plt.savefig('cubica.png')
  plt.show()

"""###Bloque de Función Exponencial"""

#Bloque de funcion exponencial
def func_exp():
  f = open("registro.txt", "a")
  vls_x = []
  vls_y = []

  print("La función exponencial cumple con la ecuación general:\nf(x) = a^x")
  a = float(input("Ingrese el valor de a: "))
  print("\nLa función cuadrática es:\nf(x) = ",a,"^x")
  fx="f(x) = "+str(a)+"^x"+"\n\n"
  f.write(fx)

  #Saber los valores iniciales y finales y cuanto paso va a haber para la evaluación

  val1 = float(input("\nIngrese el valor inferior para evaluar: "))
  val2 = float(input("Ingrese el valor superior: "))
  intervalo = float(input("Ingrese el intervalo: "))

  #Evalúa los valores de X y Y, en caso de que el valor uno sea mayor no vuelve a pedir los datos, solo los invierte
  if val1 > val2:
    while val2 <= val1:
      vls_x.append(val2)
      vls_y.append(math.pow(a,val2))
      val2 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  elif val1 < val2:
    while val1 <= val2:
      vls_x.append(val1)
      vls_y.append(math.pow(a,val1))
      val1 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  plt.plot(vls_x, vls_y)
  plt.savefig('exp.png')
  plt.show()

"""###Bloque de Función logaritmo"""

def func_log():
    f = open("registro.txt", "a")
    vls_x = []
    vls_y = []

    print("La funcion logarítmica cumple con la ecuación general:\nf(x) = log_a(x)")
    a = float(input("Ingrese el valor de a: "))

    while a <= 0 or a == 1:
        print("El valor de a debe ser mayor que 0 y diferente de 1")
        a = float(input("Ingresa el valor de a de nuevo: "))
    print("\nLa funcion logarítmica es:\nf(x) = log_",a,"(x)")
    fx="f(x) = log_"+str(a)+"(x)"+"\n\n"
    f.write(fx)

    #Saber los valores iniciales y finales y cuanto paso va a haber para la evaluación
    val1 = float(input("\nIngrese el valor inferior para evaluar (mayor que 0): "))
    val2 = float(input("Ingrese el valor superior: "))
    intervalo = float(input("Ingrese el intervalo: "))

    if val1 <= 0:
        print("El valor inferior debe ser mayor que 0. Ajustando val1 a 0.1")
        val1 = 0.1
    if val1 > val2:
        while val2 <= val1:
            if val2 > 0:
                vls_x.append(val2)
                vls_y.append(math.log(val2, a))
            val2 += intervalo
    else:
        while val1 <= val2:
            if val1 > 0:
                vls_x.append(val1)
                vls_y.append(math.log(val1, a))
            val1 += intervalo

    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
    plt.plot(vls_x, vls_y)
    plt.savefig('log.png')
    plt.show()

"""###Bloque de Función Raíz"""

#Bloque de funcion raiz
def func_raiz():
    f = open("registro.txt", "a")
    vls_x = []
    vls_y = []
    print("La función raíz cumple con la ecuación general:\nf(x) = (x)^1/n")
    n = float(input("Ingrese el valor de n: "))
    print("\nLa función raíz es:\nf(x) = x^1/", n)
    fx="f(x) = x^1/"+str(n)+"\n\n"
    f.write(fx)

    # Saber los valores iniciales y finales y cuánto paso va a haber para la evaluación
    val1 = float(input("\nIngrese el valor inferior para evaluar: "))
    val2 = float(input("Ingrese el valor superior: "))
    intervalo = float(input("Ingrese el intervalo: "))

    # Evalúa los valores de X y Y, en caso de que el valor uno sea mayor no vuelve a pedir los datos, solo los invierte
    if val1 > val2:
        while val2 <= val1:
          #Aquí se asegura de que si la función es par, omita los números negativos
            if n % 2 == 0 and val2 < 0:
                val2 += intervalo
                continue
            vls_x.append(val2)
            vls_y.append(math.pow(val2, 1/n))
            val2 += intervalo
        print("Los valores de x son: ", vls_x)
        print("Los valores de y son: ", vls_y)
    elif val1 < val2:
        while val1 <= val2:
            if n % 2 == 0 and val1 < 0:
                val1 += intervalo
                continue
            vls_x.append(val1)
            vls_y.append(math.pow(val1, 1/n))
            val1 += intervalo
        print("Los valores de x son: ", vls_x)
        print("Los valores de y son: ", vls_y)
    plt.plot(vls_x, vls_y)
    plt.savefig('raiz.png')
    plt.show()

"""###Bloque de Función Racional

"""

#Bloque de funcion racional
def func_rac():
  f = open("registro.txt", "a")
  vls_x = []
  vls_y = []

  print("La función racional cumple con la ecuación:\nf(x) = a/bx")
  a = float(input("Ingrese el valor de a: "))
  b = float(input("Ingrese el valor de b: "))
  print("\nLa función racional es:\nf(x) = ",a,"/",b,"x")
  fx="f(x) = "+str(a)+"/"+str(b)+"x"+"\n\n"
  f.write(fx)

  #Saber los valores iniciales y finales y cuanto paso va a haber para la evaluación

  val1 = float(input("\nIngrese el valor inferior para evaluar: "))
  val2 = float(input("Ingrese el valor superior: "))
  intervalo = float(input("Ingrese el intervalo: "))

  #Evalúa los valores de X y Y, en caso de que el valor uno sea mayor no vuelve a pedir los datos, solo los invierte
  if val1 > val2:
    while val2 <= val1:
      if val2 == 0:
        val2 += 0.0000000001
      vls_x.append(val2)
      vls_y.append(a/(b*val2))
      val2 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  elif val1 < val2:
    while val1 <= val2:
      if val1 == 0:
        val1 += 0.0000000001
      vls_x.append(val1)
      vls_y.append(a/(b*val1))
      val1 += intervalo
    print("Los valores de x son: ", vls_x)
    print("Los valores de y son: ", vls_y)
  plt.plot(vls_x, vls_y)
  plt.savefig('racional.png')
  plt.show()

"""###Bloque de decisión"""

#Bloque de decisión
if tipo_funcion == 1:
  func_lin()
elif tipo_funcion == 2:
  func_cua()
elif tipo_funcion == 3:
  func_cubi()
elif tipo_funcion == 4:
  func_exp()
elif tipo_funcion == 5:
  func_log()
elif tipo_funcion == 6:
  func_rac()
elif tipo_funcion == 7:
  func_raiz()